---
title: "Conceitos estatisticos para IA"
output:
  html_document: 
    code_folding: hide
    fig_caption: yes
    fig_height: 7.0
    fig_width: 14.0
    highlight: tango
    number_sections: yes
    theme: cerulean
    toc: yes
---



```{r load libraries, message=FALSE, warning=FALSE}
library(corrplot)
library(corrgram)
library(skimr)
library(knitr)
library(ggplot2)
library(dplyr)
library(formattable)
library(randomForest)
library(caret)
library(readr)
library(gmodels)
library(rpart)
library(rpart.plot)
```
******
# Introdução
******

Esta análise aplica-se a um dataset de variantes do vinho portugues "Vinho Verde", possuindo diversos indicadores de suas caracteristicas, como acidez, teor alcoolico, quantidade de açucar, entre outros... 

******
# Carregando dados
******

```{r load data}
vinhos <- read.csv("BaseWine_Red_e_White.csv", header = TRUE, sep = ";", dec = ",")
```


******
# Análise Exploratória dos Dados
******

******
## Conhecendo as variaveis
******

******
### Sumario da Base original
******
```{r}
summary(vinhos)
str(vinhos)
```

Dataset com 13 variaveis, dentre elas a variável "quality" indica a qualidade medida de cada vinho.

 - **fixedacidity:** Indica a quantidade de acidos presente no vinho (voláteis ou não voláteis);
 - **volatileacidity:** Indica a quantidade de ácido acético no vinho, que em níveis muito altos pode levar a um gosto desagradável de vinagre;
 - **citricacid:** Indica a quantidade de ácido cítrico,  pode adicionar “frescura” e sabor aos vinhos;
 - **residualsugar:** Indica a quantidade de açúcar restante depois que o processo de fermentação;
 - **chlorides:** Indica a quantidade de sal no vinho;
 - **freesulfurdioxide:** Indica a quantidade da forma livre de SO2, impede o crescimento microbiano e a oxidação do vinho, Garante condições melhores para os processos de vinificação da bebida, elimina bactérias e leveduras frágeis e indesejáveis, o que permite que apenas as melhores prossigam com o processo fermentativo. Além do mais, melhora o aroma e afina a cor da bebida;
 - **totalsulfurdioxide:** Indica a quantidade de formas livres e encadernadas de S02; em baixas concentrações, o SO2 é quase indetectável no vinho, mas nas concentrações de SO2 livre acima de 50 ppm, o SO2 se torna evidente no nariz e no sabor do vinho;
 - **density:**indica a densidade do vinho, a densidade é próxima à da água, dependendo do percentual de álcool e teor de açúcar;
 - **pH:** descreve como o vinho é acídico ou básico numa escala de 0 (muito ácido) a 14 (muito básico); a maioria dos vinhos tem entre 3-4 na escala de pH;
 - **sulphates:** Indica a quantidade de sulfatos, um aditivo de vinho que pode contribuir para os níveis de gás de dióxido de enxofre (S02), que age como um antimicrobiano e antioxidante;
 - **alcohol:** Indica o teor alcoólico percentual do vinho;
 - **quality:** variável de saída (com base em dados sensoriais) que poderiam ser de 0 a 10 sendo zero muito ruim e 10 muito excelente;
 - **Vinho:** variável qualitativa nominal que indica se o vinho é tinto ou branco.


******
## Verificação da completude da amostra
******

É importante averiguarmos a existẽncia de dados incompletos na amostra de modo que possam influenciar a análise e o desenvolvimento dos modelos estatísticos:
```{r results='asis'}
skim(vinhos) %>% skimr::kable()
```

******
## Detectando Outliers
******
Outliers são observações que apresentam grandes afastamentos das demais e/ou são inconsistentes com estas. Um bom método de verificar a existência de outliers é a análise gráfica, através de um histograma sobreposto pela distribuição normal e duas linhas que delimitem o limite mínimo e máximo de corte, também é usado o gráfico bloxpot.

```{r}
hist.default <- function(x,
                         breaks = "Sturges",
                         freq = NULL,
                         include.lowest = TRUE,
                         normalcurve = TRUE,
                         right = TRUE,
                         density = NULL,
                         angle = 45,
                         col = NULL,
                         border = NULL,
                         main = paste("Histogram of", xname),
                         ylim = NULL,
                         xlab = xname,
                         ylab = NULL,
                         axes = TRUE,
                         plot = TRUE,
                         labels = FALSE,
                         warn.unused = TRUE,
                         ...)  {
  xname <- paste(deparse(substitute(x), 500), collapse = "\n")

  suppressWarnings(
    h <- graphics::hist.default(
      x = x,
      breaks = breaks,
      freq = freq,
      include.lowest = include.lowest,
      right = right,
      density = density,
      angle = angle,
      col = col,
      border = border,
      main = main,
      ylim = ylim,
      xlab = xlab,
      ylab = ylab,
      axes = axes,
      plot = plot,
      labels = labels,
      warn.unused = warn.unused,
      ...
    )
  )

  if (normalcurve == TRUE & plot == TRUE) {
    x <- x[!is.na(x)]
    xfit <- seq(min(x), max(x), length = 40)
    yfit <- dnorm(xfit, mean = mean(x), sd = sd(x))
    if (isTRUE(freq) | (is.null(freq) & is.null(density))) {
      yfit <- yfit * diff(h$mids[1:2]) * length(x)
    }
    lines(xfit, yfit, col = "black", lwd = 2)
  }

  if (plot == TRUE) {
    invisible(h)
  } else {
    h
  }
}

plotaGraficos <- function(fVinho, label){
par(mfrow = c(1,2))
hist(fVinho, main = paste("Histograma de ",label), xlab = label, ylab="Frequência")
abline(v = mean(fVinho) - 2 * sd(fVinho), col = "red")
abline(v = mean(fVinho) + 2 * sd(fVinho), col = "red")
boxplot(fVinho)
}

plotaGraficos(vinhos$fixedacidity, "fixedacidity")
plotaGraficos(vinhos$volatileacidity, "volatileacidity")
plotaGraficos(vinhos$citricacid, "citricacid")
plotaGraficos(vinhos$residualsugar, "residualsugar")
plotaGraficos(vinhos$chlorides, "chlorides")
plotaGraficos(vinhos$freesulfurdioxide, "freesulfurdioxide")
plotaGraficos(vinhos$totalsulfurdioxide, "totalsulfurdioxide")
plotaGraficos(vinhos$density, "density")
plotaGraficos(vinhos$pH, "pH")
plotaGraficos(vinhos$sulphates, "sulphates")
plotaGraficos(vinhos$alcohol, "alcohol")
```

## Removendo Outliers
Pelo boxplot é possível visualizar que há grupos distintos de vinhos dadas as características físico-químicas e a qualidade entre eles, mas também é possível notar que nas variáveis "residualsugar", "freesilfurdioxide" e "totalsulfurdioxide" existem observações com valores muito distantes dos agrupamentos no gráfico e consideramos estas possíveis outliers, sendo assim, serão removidos para que não interfiram no resultado da análise e dos algoritmos
```{r}
vinhos <- vinhos%>%filter(residualsugar < 40)
vinhos <- vinhos%>%filter(freesulfurdioxide < 200)
vinhos <- vinhos%>%filter(totalsulfurdioxide < 400)

plotaGraficos(vinhos$residualsugar, "residualsugar")
plotaGraficos(vinhos$freesulfurdioxide, "freesulfurdioxide")
plotaGraficos(vinhos$totalsulfurdioxide, "totalsulfurdioxide")
```

******
# Correlação de variaveis
******

Gerando a correlação das variaveis, vai permitir o entendimento de quais carácteristicas estão mais relacionadas a nota de qualidade dadas aos vinho.

Vamos começar pela matriz de correlação.

## Matriz de Correlação

 Matriz de correlação mostra os valores de correlação de Pearson, que medem o grau de relação linear entre cada par de itens ou variáveis. Os valores de correlação podem cair entre -1 e +1.

```{r}
matcor <- cor(vinhos%>%select(2:13))
panel.cor <- function(x, y, digits=2, prefix ="", cex.cor,
                      ...)  {
  usr <- par("usr")
  on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- cor(x, y , use = "pairwise.complete.obs")
  txt <- format(c(r, 0.123456789), digits = digits) [1]
  txt <- paste(prefix, txt, sep = "")
  if (missing(cex.cor))
    cex <- 0.8/strwidth(txt)
  text(0.5, 0.5, txt, cex = cex * abs(r))
}
pairs(vinhos%>%select(2:13), lower.panel=panel.smooth, upper.panel=panel.cor)
```

### Conclusão

A Qualidade dos vinhos apresenta correlação com o teor alcoólico, densidade e acidez volátil, ainda que não seja um alto grau de correlação, porém, outras variáveis do dataset apresentam alta correlação entre si.

## Estimando a qualidade do vinho 
Tendo como alvo a qualidade dos vinhos, usaremos as características físico-químicas dos mesmos e usaremos duas técnicas diferentes para obtermos nossa variável de resposta.

### Regressão Linear
A regressão linear consiste em uma função que relaciona as variáveis que contém características do objeto de estudo a uma varíavel depente do mesmo objeto de estudo, gerando assim uma relação entre o resultado observado às suas possíveis explicações.

Usaremos o método stepwise no desenvolvimento do modelo, selecionando assim as variáveis que melhor estimem a qualidade do vinho

```{r, message=FALSE, warning=FALSE}
vinhos_rl <- vinhos%>%select(2:13)
modelo_rl <- lm(vinhos$quality ~ vinhos_rl$fixedacidity + vinhos_rl$volatileacidity + vinhos_rl$citricacid + vinhos_rl$residualsugar + vinhos_rl$chlorides + vinhos_rl$freesulfurdioxide + vinhos_rl$totalsulfurdioxide + vinhos_rl$density + vinhos_rl$pH + vinhos_rl$sulphates + vinhos_rl$alcohol)
stepwise<-step(modelo_rl,direction="both")
summary(stepwise)

```
Através da sumarização do modelo podemos observar que a quantidade de sal presente nos vinhos não é relevante para a estimarmos a qualidade e será removida da modelo final

```{r, message=FALSE, warning=FALSE}
modelo_rl_final <- lm(vinhos_rl$quality ~ vinhos_rl$fixedacidity + vinhos_rl$volatileacidity + vinhos_rl$citricacid + vinhos_rl$residualsugar + vinhos_rl$freesulfurdioxide + vinhos_rl$totalsulfurdioxide + vinhos_rl$density + vinhos_rl$pH + vinhos_rl$sulphates + vinhos_rl$alcohol)
```
******
#### Análise de resíduos

******
Com o gráfico abaixo podemos concluir que os resíduos da predição com o modelo desenvolvido que a premissa de normalidade é atendida:
```{r}
qqnorm(residuals(modelo_rl_final), ylab="Resíduos",xlab="Quantis teóricos",main="")
qqline(residuals(modelo_rl_final))
```
Concluímos que com o modelo de regressão desenvolvido temos um erro quadrático médio de aproximadamente 0,74.
```{r}
pred <- predict(modelo_rl_final,interval = "prediction", level = 0.95) 
fit <- pred[,1]
mse <- mean((vinhos_rl$quality  - fit)^2)
sqrt(mse)
```
### Arvore de Regressão

```{r}
modelo_arvore <- rpart(vinhos_rl$quality ~ vinhos_rl$quality ~ vinhos_rl$fixedacidity + vinhos_rl$volatileacidity + vinhos_rl$citricacid + vinhos_rl$residualsugar + vinhos_rl$freesulfurdioxide + vinhos_rl$totalsulfurdioxide + vinhos_rl$density + vinhos_rl$pH + vinhos_rl$sulphates + vinhos_rl$alcohol, data=vinhos_rl, 
                     cp = 0.001,minsplit = 15,maxdepth=10)

rpart.plot(modelo_arvore, type=4, extra=1, under=FALSE, clip.right.labs=TRUE,
           fallen.leaves=FALSE,   digits=2, varlen=-10, faclen=20,
           cex=0.4, tweak=1.7,
           compress=TRUE, 
           snip=FALSE)
```

***
# Correlação + Cluster
***

Incluindo cluster sobre os relacionamentos identificados

```{r,message=FALSE,warning=FALSE}
#corrplot(cor(vinhosret), order = "hclust", addrect = 2)
```

Pela análise temos algumas variáveis que parecem ter relação com a variavel quality: alcohol, 



******
# Gráficos de dispersão
******

Gerando gráficos de dispersão com todas as variáveis que apresentaram algum tipo de relação com a variável que decide a qualidade(quality) dos vinhos


```{r}
#par (mfrow=c(2,2))
#plot (x = vinhosret$alcohol, y = vinhosret$quality,
    #  main = "Relação com Teor alcoólico",
   #   xlab = "Álcool",
    #  ylab = "Qualidade")

#plot (x = vinhosret$citricacid, y = vinhosret$quality,
  #    main = "Relação com Ácido cítrico",
    #  xlab = "Ácido cítrico",
   #   ylab = "Qualidade")

#plot (x = vinhosret$freesulfurdioxide, y = vinhosret$quality,
  #    main = "Relação com Dióxido de enxofre livre",
    #  xlab = "Dióxido de enxofre livre",
   #   ylab = "Qualidade")

#plot (x = vinhosret$density, y = vinhosret$quality,
    #  main = "Relação com Densidade",
   #   xlab = "Densidade",
    #  ylab = "Qualidade")

#plot (x = vinhosret$volatileacidity, y = vinhosret$quality,
   #   main = "Relação com Acidez volátil",
    #  xlab = "Acidez volátil",
    #  ylab = "Qualidade")

#plot (x = vinhosret$totalsulfurdioxide, y = vinhosret$quality,
    #  main = "Relação com Dióxido de enxofre total",
   #   xlab = "Dióxido de enxofre total",
    #  ylab = "Qualidade")

#plot (x = vinhosret$chlorides, y = vinhosret$quality,
  #    main = "Relação com Cloretos",
    #  xlab = "Cloretos",
    #  ylab = "Qualidade")

#plot (x = vinhosret$pH, y = vinhosret$quality,
    #  main = "Relação com pH",
     # xlab = "pH",
    #  ylab = "Qualidade")

```

# Criando massa de teste e treino
Para esse passo, separamos 70% da base como modelo de aprendizagem para treinar os algoritmos e 30% da base como modelo de testes, para validarmos se os algoritmos possuem assertividade

```{r}
#set.seed(1337)
#indice_vinho <- createDataPartition(vinhosret$quality, p=0.7, list=F)
#treino <- as.data.frame(vinhosret[indice_vinho, ])
#teste <- as.data.frame(vinhosret[-indice_vinho, ])

```

# Regressão linear
Primeiramente vamos executar um algoritmo de regressão linear, com o intuito de iniciar o processo de estimar a variavel quality

```{r}
#model <- lm(treino$quality ~ treino$freesulfurdioxide+treino$totalsulfurdioxide+treino$density+treino$chlorides+treino$alcohol+treino$sulphates+treino$volatileacidity+treino$density)
#summary(model)
#val_pred <- predict(model, newdata=teste, interval = 'prediction', level = 0.80)
#summary(val_pred)

```

```{r}
#ggplot(data=model, aes(model$residuals)) +
#geom_histogram(binwidth = 1, color = "black", fill = "red4") +
#theme(panel.background = element_rect(fill = "white"),
#axis.line.x=element_line(),
#axis.line.y=element_line()) +
#ggtitle("Histograma dos Residuos")
```

```{r}
#ggplot(data = vinhos, aes(x = vinhos$quality, y = vinhos$freesulfurdioxide+vinhos$totalsulfurdioxide+vinhos$density+vinhos$chlorides+vinhos$alcohol+vinhos$sulphates+vinhos$volatileacidity+vinhos$density)) +
#geom_point() +
#stat_smooth(method = "lm", col = "dodgerblue3") +
#theme(panel.background = element_rect(fill = "white"),
#axis.line.x=element_line(),
#axis.line.y=element_line()) +
#ggtitle("Modelo linear dos dados")
```

